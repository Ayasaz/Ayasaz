[{"title":"java位移运算符:<<(左移)，>>(带符号右移)和>>>(无符号右移)","slug":"java位移运算符","date":"2018-11-25T04:15:38.000Z","updated":"2018-11-25T04:36:56.991Z","comments":true,"path":"2018/11/25/java位移运算符/","link":"","permalink":"http://yoursite.com/2018/11/25/java位移运算符/","excerpt":"","text":"今天在看别人代码时看到了位移运算符，感觉自己对这些符号有点陌生，在网上看了下dalao们的理解，姑且自己整理归纳一下。1、 左移运算符 左移运算符&lt;&lt;使指定值的所有位都左移规定的次数。 1）它的通用格式如下所示： value &lt;&lt; num num 指定要移位值value 移动的位数。 左移的规则只记住一点：丢弃最高位，0补最低位 如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动37位，实际上只移动了37对32求余位。 2）运算规则 按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。 当左移的运算数是int 类型时，每移动1位它的第31位就要被移出并且丢弃； 当左移的运算数是long 类型时，每移动1位它的第63位就要被移出并且丢弃。 当左移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。2、 右移运算符 右移运算符&lt;&lt;使指定值的所有位都右移规定的次数。 1）它的通用格式如下所示： value &gt;&gt; num num 指定要移位值value 移动的位数。 右移的规则只记住一点：符号位不变，左边补上符号位 2）运算规则： 按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1 当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。 例如，如果要移走的值为负数，每一次右移都在左边补1，如果要移走的值为正数，每一次右移都在左边补0，这叫做符号位扩展（保留符号位）（sign extension ），在进行右移 操作时用来保持负数的符号。 3、无符号右移 无符号右移运算符&gt;&gt;&gt; 它的通用格式如下所示： value &gt;&gt;&gt; num num 指定要移位值value 移动的位数。 无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位 无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义 无符号右移运算符&gt;&gt;&gt; 只是对32位和64位的值有意义","categories":[],"tags":[{"name":"-随笔 -java","slug":"随笔-java","permalink":"http://yoursite.com/tags/随笔-java/"}]},{"title":"equals与双等号(==)的区别","slug":"test","date":"2018-11-24T03:40:54.000Z","updated":"2018-11-24T11:01:50.079Z","comments":true,"path":"2018/11/24/test/","link":"","permalink":"http://yoursite.com/2018/11/24/test/","excerpt":"","text":"双等号(==): 是关系运算符,用来比较两个数据是否相等(关系运算符的运算结果一定是一个Boolean值; 比较的是变量所带的内存地址是否一样。equals: 用来比较两个对象是否“相等”,equals是Object类中提供的一个方法,这个方法的初始行为是比较对象的内存地址,但是在一些类库存里这个方法是被重写了的;如String,Integer。在这些类中,equals有它本身的实现,不再是比较在对内存中存放的地址。 ####jdk中有关于equals详细的说明####1234567891011121314151617/** * 测试String类的equals方法* @author* */public class testString &#123;public static void main(String[] args) &#123; String str1=\"violet\"; String str2=\"violet\"; String str3=new String(\"violet\"); System.out.println(str1 == str2); //true System.out.println(str2 == str3); //false System.out.println(str1.equals(str2)); //true System.out.println(str2.equals(str3)); //true &#125;&#125; 在str1=”violet”被创建时,Str1就被存放在常量池中。在创建str2时，程序找到了据有相同值的str1， 此时str2引用str1所应用的对象”violet”.str3使用了new 新建了一个新的对象。所以str3与str2和str1的内存地址不同，但str3所存放的内容与str1和str2相同。","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"java多线程","slug":"java多线程","date":"2018-10-22T06:38:33.000Z","updated":"2018-10-24T06:38:22.847Z","comments":true,"path":"2018/10/22/java多线程/","link":"","permalink":"http://yoursite.com/2018/10/22/java多线程/","excerpt":"","text":"多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发机制的一个基本单位。线程是比进程更小的执行单位，线程实在进程基础上的进一步划分。所谓的多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的程序单元称为线程，这些线程可以同时存在，同时运行，一个进程可以包含多个同时执行的线程。 java中实现线程有两种手段，一种是实现Thread类，另一种就是实现Runnable接口。 Runnable接口相对与Therad类来说，有以下显著优势: 1,适合多个相同的程序代码去处理同一资源的情况。 2,可以避免由于java单继承特性带来的局限性。 3,增强了程序的健壮性，代码能被多个线程共享，代码与数据是独立的。","categories":[],"tags":[{"name":"-java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hibernate学习笔记","slug":"Hibernate学习笔记","date":"2018-09-18T13:37:21.000Z","updated":"2018-10-09T11:34:06.869Z","comments":true,"path":"2018/09/18/Hibernate学习笔记/","link":"","permalink":"http://yoursite.com/2018/09/18/Hibernate学习笔记/","excerpt":"","text":"Hibernate持久化类的主要规则，然而，在这些规则中，没有一条是硬性要求 所有将被持久化的 Java 类都需要一个默认的构造函数。 为了使对象能够在 Hibernate 和数据库中容易识别，所有类都需要包含一个 ID。此属性映射到数据库表的主键列。所有将被持久化的属性都应该声明为 private，并具有由 JavaBean 风格定义的 getXXX 和 setXXX 方法。 Hibernate 的一个重要特征为代理，它取决于该持久化类是处于非 final 的，还是处于一个所有方法都声明为 public 的接口。 所有的类是不可扩展或按 EJB 要求实现的一些特殊的类和接口。 Hibernate属性:1,hibernate.dialect 这个属性使 Hibernate 应用为被选择的数据库生成适当的 SQL。2,hibernate.connection 1).hibernate.connection.driver_class JDBC 驱动程序类。 2).hibernate.connection.url 数据库实例的 JDBC URL。 3).hibernate.connection.pool_size 限制在 Hibernate 应用数据库连接池中连接的数量 4).hibernate.connection.autocommit 允许在 JDBC 连接中使用自动提交模式。 Hibernate 查询语言 Hibernate 查询语言（HQL）是一种面向对象的查询语言，类似于 SQL，但不是去对表和列进行操作，而是面向对象和它们的属性。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。 尽管你能直接使用本地 SQL 语句，但我还是建议你尽可能的使用 HQL 语句，以避免数据库关于可移植性的麻烦，并且体现了 Hibernate 的 SQL 生成和缓存策略。 在 HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但是一些属性比如表名和列名是区分大小写的。 *可以使用cerateSQLQuery(String Sql)的方法来创建一个原始的sql查询。","categories":[],"tags":[{"name":"-java -hibernate","slug":"java-hibernate","permalink":"http://yoursite.com/tags/java-hibernate/"}]},{"title":"hello hexo!","slug":"hello-world","date":"2018-05-09T09:38:40.000Z","updated":"2018-05-21T09:58:53.038Z","comments":true,"path":"2018/05/09/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/09/hello-world/","excerpt":"","text":"你好 hexo！","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]