[{"title":"2019/6/8毕业了","slug":"2019-6-8毕业了","date":"2019-06-08T13:14:03.000Z","updated":"2019-06-09T17:23:25.890Z","comments":true,"path":"2019/06/08/2019-6-8毕业了/","link":"","permalink":"http://yoursite.com/2019/06/08/2019-6-8毕业了/","excerpt":"","text":"时光荏苒，4年的大学时光画上了句点。当我卷起我的铺盖，看着和我相处了4年的室友，心中还是有些许伤感。回想我这四年大学生活，虽说和高中幻想的大学生活天差地别，但也还不错，给我留下了很多难忘的回忆。我想也许可以趁我还记得的时候把它写下来。希望以后大家都能过得很好。得好好加油了鸭！","categories":[],"tags":[{"name":"-心情日记","slug":"心情日记","permalink":"http://yoursite.com/tags/心情日记/"}]},{"title":"简单shell脚本的编写","slug":"简单shell脚本的编写","date":"2019-06-04T14:53:44.000Z","updated":"2019-06-09T16:03:41.827Z","comments":true,"path":"2019/06/04/简单shell脚本的编写/","link":"","permalink":"http://yoursite.com/2019/06/04/简单shell脚本的编写/","excerpt":"","text":"shell教程:https://www.runoob.com/linux/linux-shell-passing-arguments.html使用shell编写一个简单的脚本，来创建一个生产者来发送kafak的消息12345#!/bin/bash#进入kafak的安装目录cd /usr/local/src/kafka#创建一个producer来接来向指定topic发送消息 $1为传入的参数bin/kafka-console-producer.sh --broker-list 192.168.6.128:9092 --topic $1 运行示例1./kafak-quick-creat.sh TestTopic 遇到的问题及解决方案12[root@localhost nozomi]# ./kafak-quick-creat.shbash: ./kafak-quick-creat.sh: /bin/bash^M: bad interpreter: No such file or directory 由于编码的原因使得路径后面多处一个^M,shell脚本使用了dos格式，我们应该使用unix格式。用vi打开shell脚本使用1: set ff 可以查看shell脚本的格式，如果文件为dos格式在显示为fileformat=dos，如果是unxi则显示为fileformat=unix。使用linux命令dos2unix filename可以将dos改为unix。如果无法使用该命令可以尝试安装1yum install dos2unix 格式转换完成后即可正常运行。","categories":[],"tags":[{"name":"-linux -shell","slug":"linux-shell","permalink":"http://yoursite.com/tags/linux-shell/"}]},{"title":"java异常的处理机制和原则","slug":"java异常的处理机制和原则","date":"2019-06-03T13:24:42.000Z","updated":"2019-06-09T14:46:08.848Z","comments":true,"path":"2019/06/03/java异常的处理机制和原则/","link":"","permalink":"http://yoursite.com/2019/06/03/java异常的处理机制和原则/","excerpt":"","text":"在平时的开发中，充分的发挥异常的优点，可以提高程序的可读性，可扩展性和可维护性。描述一个方法抛出的异常，是正确使用该方法文档的重要组成部分，因此在开发时可以多花点时间来为方法的异常进行文档注释。 在进行文档注释时，始终要单独的声明受检异常，并且利用文档注释javadoc的@throws,准确的记录抛出每个异常的条件。如果一个方法可以抛出多个异常类，不要使用抛出这些异常类的超类，特别是在使用例如idea这样的ide时，要单独的抛出异常而不是直接’throws Exception’,这样的话无法提供这个方法能抛出哪些异常的任何有效息。因为一个需求在实现时会调用多个方法，这些方法在使用过程中都可以抛出其它的异常，因此最好是单独的声明授监察异常。语法12语法：[(修饰符)](返回值类型)(方法名)([参数列表])[throws(异常类)]&#123;......&#125;public void doA(int a) throws Exception1,Exception3&#123;......&#125; 摘自effective java","categories":[],"tags":[{"name":"-java -Expection  -读书笔记","slug":"java-Expection-读书笔记","permalink":"http://yoursite.com/tags/java-Expection-读书笔记/"}]},{"title":"java使用Document实现MongoDB聚合查询","slug":"java使用Document实现MongoDB聚合查询","date":"2019-05-20T18:24:23.000Z","updated":"2019-05-20T19:45:48.611Z","comments":true,"path":"2019/05/21/java使用Document实现MongoDB聚合查询/","link":"","permalink":"http://yoursite.com/2019/05/21/java使用Document实现MongoDB聚合查询/","excerpt":"","text":"MongoDB官方文档MongoDB以文档的方式存放数据,它的数据以Key=&gt;value的形式的bson。在查询MongoDB时经常需要使用到较为复杂的查询语句对数据进行筛选($match),分组聚合($group)此时我们可以在java中使用Document来拼接查询语句。在手写好正确的MongoDB语句后,我们可以把它分为多个Document对象。每一个”{}”里面都是一个Document对象每一个”[]”里面都是一个List对象使用这个方法，在确定查询语句的情况下,可以很快的在java中组装查询语1[&#123;&quot;$match&quot;:&#123;&quot;$or&quot;:[&#123;&quot;carparkid&quot;:&quot;10001213&quot;&#125;,&#123;&quot;carparkid&quot;:&quot;10001215&quot;&#125;]&#125;&#125;,&#123;&quot;$match&quot;:&#123;&quot;timestamp&quot;:&#123;&quot;$gte&quot;:1557936000000,&quot;$lt&quot;:1558022400000&#125;&#125;&#125;,&#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$dateDay&quot;,&quot;amountCount&quot;:&#123;&quot;$sum&quot;:&quot;$amountCount&quot;&#125;,&quot;amountReceivedTotal&quot;:&#123;&quot;$sum&quot;:&quot;$amountReceivedTotal&quot;&#125;,&quot;alipayChannelAmountReceived&quot;:&#123;&quot;$sum&quot;:&quot;$alipayChannelAmountReceived&quot;&#125;,&quot;wechatChannelAmountReceived&quot;:&#123;&quot;$sum&quot;:&quot;$wechatChannelAmountReceived&quot;&#125;,&quot;cashChannelAmountReceived&quot;:&#123;&quot;$sum&quot;:&quot;$cashChannelAmountReceived&quot;&#125;,&quot;otherChannelAmountReceived&quot;:&#123;&quot;$sum&quot;:&quot;$otherChannelAmountReceived&quot;&#125;&#125;&#125;] 组装以上查询语句的Document1234567891011121314carparkMatch.put(&quot;$match&quot;,new Document(&quot;$or&quot;,carparkidDocumentList)); match.put(&quot;$match&quot;,new Document(&quot;timestamp&quot;,new Document(&quot;$gte&quot;,dayPeriod.getDayBeginTime()).append(&quot;$lt&quot;,dayPeriod.getDayEndTime()))); sub_group.put(&quot;_id&quot;,reportKey); sub_group.put(&quot;amountCount&quot;,new Document(&quot;$sum&quot;,&quot;$amountCount&quot;)); sub_group.put(&quot;amountReceivedTotal&quot;,new Document(&quot;$sum&quot;,&quot;$amountReceivedTotal&quot;)); sub_group.put(&quot;alipayChannelAmountReceived&quot;,new Document(&quot;$sum&quot;,&quot;$alipayChannelAmountReceived&quot;)); sub_group.put(&quot;wechatChannelAmountReceived&quot;,new Document(&quot;$sum&quot;,&quot;$wechatChannelAmountReceived&quot;)); sub_group.put(&quot;cashChannelAmountReceived&quot;,new Document(&quot;$sum&quot;,&quot;$cashChannelAmountReceived&quot;)); sub_group.put(&quot;otherChannelAmountReceived&quot;,new Document(&quot;$sum&quot;,&quot;$otherChannelAmountReceived&quot;)); group.put(&quot;$group&quot;,sub_group); queryParam.add(carparkMatch); queryParam.add(match); queryParam.add(group); return queryParam;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JSP的9大内置对象和四大作用域","slug":"JSP的9大内置对象","date":"2018-12-21T09:48:01.000Z","updated":"2019-04-09T12:59:00.756Z","comments":true,"path":"2018/12/21/JSP的9大内置对象/","link":"","permalink":"http://yoursite.com/2018/12/21/JSP的9大内置对象/","excerpt":"","text":"1.9大内置对象 名称 类型 作用 获取方法 request HttpServletRequest 封装所有请求信息 方法参数 response HttpSevletResponse 封装所有响应信息 方法参数 session HttpSession 封装所有会话信息 req.getSession() application ServletContext 所有信息 getServletContext();request.getServletContext out PrintWriter 输出对象 response.getWriter() exception Exception 异常对象 page Object 当前页面对象 pageContext PangeContext 获取其他对象 config ServletConfig 配置信息 2.四大作用域 2.1 page 2.1.1 在当前页面不会重新实例化. 2.2request 2.2.1 在一次请求中同一个对象,下次请求重新实例化一个 2.3session 2.3.1 一次会话.2.3.2 只要客户端Cookie中传递的Jsessionid不变,Session不会重新实力会(不超过默认时间.)2.3.3 实际有效时间: 2.3.3.1 浏览器关闭.Cookie 失效.2.3.3.2 默认时间.在时间范围内无任何交互.在 tomcat 的web.xml 中配置&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 2.4application 2.4.1 只有在 tomcat 启动项目时菜实例化.关闭 tomcat 时销毁application","categories":[],"tags":[{"name":"-java  -jsp","slug":"java-jsp","permalink":"http://yoursite.com/tags/java-jsp/"}]},{"title":"设计模式之单例设计模式","slug":"设计模式-单例设计模式","date":"2018-12-17T13:52:10.000Z","updated":"2018-12-17T14:41:25.229Z","comments":true,"path":"2018/12/17/设计模式-单例设计模式/","link":"","permalink":"http://yoursite.com/2018/12/17/设计模式-单例设计模式/","excerpt":"","text":"单例设计模式： 作用：在应用程序中保证只能有一个实例。 优点: 1,提升运行效率，在jvm虚拟机加载时就创建好了对象。 2,实现数据共享，案例:applicationcontext对象(tomcat启动到tomcat关闭一直有效).12345678910111213141516171819202122232425262728293031323334353637package pojo;/** * 单例设计模式-懒汉式 * @author 张攀 */public class SingleTonDemo &#123; /** * 静态方法不能调用非静态变量 * 由于对象时static,所以访问修饰符为private */ private static SingleTonDemo singleTon; /** * 构造方法私有化,其他类无法实例化该对象 * 对外提供一个公有的访问入口 */ public SingleTonDemo()&#123; System.out.println(&quot;单例设计模式之懒汉式&quot;); &#125; /** * 因为其他类无法实例化该对象,所以这个方法设置为静态方法 * 多线程访问下可能出现if同时成立的情况，所以我们要添加一个锁 * @return */ public static SingleTonDemo getInstance()&#123; if (singleTon==null) &#123; synchronized (SingleTonDemo.class) &#123; if (singleTon==null) &#123; //双重验证 singleTon = new SingleTonDemo(); &#125; &#125; &#125; return singleTon; &#125;&#125; 懒汉式由于添加了锁，降低了效率。懒汉最终还是变成了饿汉。饿汉式：1234567891011121314151617181920package pojo;/** * 单例设计模式-饿汉式 * @author 张攀 * */public class SingleTon &#123; /** * 在类被加载时就会被实例化 */ private static SingleTon singleTon = new SingleTon(); private SingleTon()&#123; //私有化构造方法 System.out.println(&quot;单例设计模式-饿汉式&quot;); &#125; //公有的访问方法 public SingleTon getSingleTon()&#123; return singleTon; &#125;&#125; 相对懒汉式,饿汉式不仅代码更加精简,而且运行效率还比懒汉式更高.能想办法去偷懒的人反而能创造出更高的效率,学习是要多总结多归纳。","categories":[],"tags":[{"name":"-java -设计模式","slug":"java-设计模式","permalink":"http://yoursite.com/tags/java-设计模式/"}]},{"title":"linux下安装Shadowsocks","slug":"linux下安装Shadowsocks","date":"2018-12-16T15:32:12.000Z","updated":"2019-04-09T13:08:46.923Z","comments":true,"path":"2018/12/16/linux下安装Shadowsocks/","link":"","permalink":"http://yoursite.com/2018/12/16/linux下安装Shadowsocks/","excerpt":"","text":"首先,下载安装文件1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 然后更改文件的执行权限1chmod +x shadowsocks.sh 最后执行以下命令，将标准错误和标准输出记录到日志中1./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 中间会要求输入密码，端口，和加密方式。加密方式因为一般选用aes-256-cfb。最后完成后shadowsocks会把这些信息打印出来。","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"MyBatis常见错误持续更新","slug":"MyBatis常见错误持续更新","date":"2018-12-11T08:16:18.000Z","updated":"2018-12-12T03:59:04.965Z","comments":true,"path":"2018/12/11/MyBatis常见错误持续更新/","link":"","permalink":"http://yoursite.com/2018/12/11/MyBatis常见错误持续更新/","excerpt":"","text":"12### Error updating database. Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for ????????### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for ?????? 错误原因:通常是没有在mybatis.tld中配置 配置好即可解决 1234Exception in thread &quot;main&quot; org.apache.ibatis.binding.BindingException: Type interface ????? is not known to the MapperRegistry. at org.apache.ibatis.binding.MapperRegistry.getMapper(MapperRegistry.java:47) at org.apache.ibatis.session.Configuration.getMapper(Configuration.java:655) at org.apache.ibatis.session.defaults.DefaultSqlSession.getMapper(DefaultSqlSession.java:222) 使用getMapper绑定接口时没有在mybatis.tld中配置mappers下package(package为mapper和接口所在的包)","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"2018/12/9","slug":"2018-12-9","date":"2018-12-09T08:36:15.000Z","updated":"2018-12-09T08:54:11.722Z","comments":true,"path":"2018/12/09/2018-12-9/","link":"","permalink":"http://yoursite.com/2018/12/09/2018-12-9/","excerpt":"","text":"今天在做MyBatis网页的分页练习时遇到了点麻烦，关键信息123456### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;null,null&apos; at line 1### The error may exist in mapper/PageMapper.tld### The error may involve page.selByPage-Inline### The error occurred while setting parameters### SQL: select * from student limit ?,?### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;null,null&apos; at line 1 log4j日志12345678910[DEBUG] 2018-12-09 16:31:14,887 method:org.apache.ibatis.datasource.pooled.PooledDataSource.popConnection(PooledDataSource.java:380)Created connection 1301827804.[DEBUG] 2018-12-09 16:31:14,888 method:org.apache.ibatis.transaction.jdbc.JdbcTransaction.setDesiredAutoCommit(JdbcTransaction.java:98)Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@4d9850dc][DEBUG] 2018-12-09 16:31:14,890 method:org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:139)==&gt; Preparing: select * from student limit ?,?[DEBUG] 2018-12-09 16:31:14,919 method:org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:139)==&gt; Parameters: null, null[DEBUG] 2018-12-09 16:32:36,028 method:org.apache.ibatis.datasource.pooled.PooledDataSource.forceCloseAll(PooledDataSource.java:306)PooledDataSource forcefully closed/removed all connections. 已解决 原因：Parameters: null, null参数没有传到Sql语句中","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"2018/12/6","slug":"2018-12-6","date":"2018-12-06T12:43:26.000Z","updated":"2018-12-06T12:48:28.799Z","comments":true,"path":"2018/12/06/2018-12-6/","link":"","permalink":"http://yoursite.com/2018/12/06/2018-12-6/","excerpt":"","text":"今天在练习时用toString输出list出现了如下问题12345678InputStream is = Resources.getResourceAsStream(\"mybatis.tld\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is); SqlSession session = factory.openSession(); List&lt;Student&gt; list= session.selectList(\"nozomi.selAll\"); for(Student student : list)&#123; System.out.println(student.toString()); &#125; session.close(); 结果1234pojo.Student@72d818d1pojo.Student@6e06451epojo.Student@59494225pojo.Student@6e1567f1 问题原因:没有在重写toString方法","categories":[],"tags":[{"name":"-随笔  -java","slug":"随笔-java","permalink":"http://yoursite.com/tags/随笔-java/"}]},{"title":"java位移运算符:<<(左移)，>>(带符号右移)和>>>(无符号右移)","slug":"java位移运算符","date":"2018-11-25T04:15:38.000Z","updated":"2018-11-26T11:02:11.856Z","comments":true,"path":"2018/11/25/java位移运算符/","link":"","permalink":"http://yoursite.com/2018/11/25/java位移运算符/","excerpt":"","text":"今天在看别人代码时看到了位移运算符，感觉自己对这些符号有点陌生，在网上看了下dalao们的理解，姑且自己整理归纳一下。1、 左移运算符 左移运算符&lt;&lt;使指定值的所有位都左移规定的次数。 1）它的通用格式如下所示： value &lt;&lt; num num 指定要移位值value 移动的位数。 左移的规则只记住一点：丢弃最高位，0补最低位 如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动37位，实际上只移动了37对32求余5位。 2）运算规则 按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。 当左移的运算数是int 类型时，每移动1位它的第31位就要被移出并且丢弃； 当左移的运算数是long 类型时，每移动1位它的第63位就要被移出并且丢弃。 当左移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。2、 右移运算符 右移运算符&lt;&lt;使指定值的所有位都右移规定的次数。 1）它的通用格式如下所示： value &gt;&gt; num num 指定要移位值value 移动的位数。 右移的规则只记住一点：符号位不变，左边补上符号位 2）运算规则： 按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1 当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。 例如，如果要移走的值为负数，每一次右移都在左边补1，如果要移走的值为正数，每一次右移都在左边补0，这叫做符号位扩展（保留符号位）（sign extension ），在进行右移 操作时用来保持负数的符号。 3、无符号右移 无符号右移运算符&gt;&gt;&gt; 它的通用格式如下所示： value &gt;&gt;&gt; num num 指定要移位值value 移动的位数。 无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位 无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义 无符号右移运算符&gt;&gt;&gt; 只是对32位和64位的值有意义","categories":[],"tags":[{"name":"-随笔 -java","slug":"随笔-java","permalink":"http://yoursite.com/tags/随笔-java/"}]},{"title":"equals与双等号(==)的区别","slug":"test","date":"2018-11-24T03:40:54.000Z","updated":"2018-11-26T12:04:29.280Z","comments":true,"path":"2018/11/24/test/","link":"","permalink":"http://yoursite.com/2018/11/24/test/","excerpt":"","text":"双等号(==): 是关系运算符,用来比较两个数据是否相等(关系运算符的运算结果一定是一个Boolean值; 比较的是变量所带的内存地址是否一样。equals: 用来比较两个对象是否“相等”,equals是Object类中提供的一个方法,这个方法的初始行为是比较对象的内存地址,但是在一些类库存里这个方法是被重写了的;如String,Integer。在这些类中,equals有它本身的实现,不再是比较在对内存中存放的地址。 ####jdk中有关于equals详细的说明####1234567891011121314151617/** * 测试String类的equals方法* @author* */public class testString &#123;public static void main(String[] args) &#123; String str1=\"violet\"; String str2=\"violet\"; String str3=new String(\"violet\"); System.out.println(str1 == str2); //true System.out.println(str2 == str3); //false System.out.println(str1.equals(str2)); //true System.out.println(str2.equals(str3)); //true &#125;&#125; 在str1=”violet”被创建时,Str1就被存放在常量池中。在创建str2时，程序找到了据有相同值的str1， 此时str2引用str1所应用的对象”violet”.str3使用了new 新建了一个新的对象。所以str3与str2和str1的内存地址不同，但str3所存放的内容与str1和str2相同。 ########################################################################今天看到了一个关于使用连接符拼接字符的比较如下123456789public class TestEquals &#123; public static void main(String args[])&#123; String a=\"violet\"; String b=\"vio\"+\"let\"; String c=new String(\"viol\"+\"et\"); System.out.println(a==b); //true System.out.println(c.equals(b)); //true &#125;&#125; a和使用连接符拼接的b使用”==”比较后的返回值位true,说明a和b指向的是同一个对象“violet”。","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"java多线程","slug":"java多线程","date":"2018-10-22T06:38:33.000Z","updated":"2018-10-24T06:38:22.847Z","comments":true,"path":"2018/10/22/java多线程/","link":"","permalink":"http://yoursite.com/2018/10/22/java多线程/","excerpt":"","text":"多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发机制的一个基本单位。线程是比进程更小的执行单位，线程实在进程基础上的进一步划分。所谓的多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的程序单元称为线程，这些线程可以同时存在，同时运行，一个进程可以包含多个同时执行的线程。 java中实现线程有两种手段，一种是实现Thread类，另一种就是实现Runnable接口。 Runnable接口相对与Therad类来说，有以下显著优势: 1,适合多个相同的程序代码去处理同一资源的情况。 2,可以避免由于java单继承特性带来的局限性。 3,增强了程序的健壮性，代码能被多个线程共享，代码与数据是独立的。","categories":[],"tags":[{"name":"-java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hibernate学习笔记","slug":"Hibernate学习笔记","date":"2018-09-18T13:37:21.000Z","updated":"2018-10-09T11:34:06.869Z","comments":true,"path":"2018/09/18/Hibernate学习笔记/","link":"","permalink":"http://yoursite.com/2018/09/18/Hibernate学习笔记/","excerpt":"","text":"Hibernate持久化类的主要规则，然而，在这些规则中，没有一条是硬性要求 所有将被持久化的 Java 类都需要一个默认的构造函数。 为了使对象能够在 Hibernate 和数据库中容易识别，所有类都需要包含一个 ID。此属性映射到数据库表的主键列。所有将被持久化的属性都应该声明为 private，并具有由 JavaBean 风格定义的 getXXX 和 setXXX 方法。 Hibernate 的一个重要特征为代理，它取决于该持久化类是处于非 final 的，还是处于一个所有方法都声明为 public 的接口。 所有的类是不可扩展或按 EJB 要求实现的一些特殊的类和接口。 Hibernate属性:1,hibernate.dialect 这个属性使 Hibernate 应用为被选择的数据库生成适当的 SQL。2,hibernate.connection 1).hibernate.connection.driver_class JDBC 驱动程序类。 2).hibernate.connection.url 数据库实例的 JDBC URL。 3).hibernate.connection.pool_size 限制在 Hibernate 应用数据库连接池中连接的数量 4).hibernate.connection.autocommit 允许在 JDBC 连接中使用自动提交模式。 Hibernate 查询语言 Hibernate 查询语言（HQL）是一种面向对象的查询语言，类似于 SQL，但不是去对表和列进行操作，而是面向对象和它们的属性。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。 尽管你能直接使用本地 SQL 语句，但我还是建议你尽可能的使用 HQL 语句，以避免数据库关于可移植性的麻烦，并且体现了 Hibernate 的 SQL 生成和缓存策略。 在 HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但是一些属性比如表名和列名是区分大小写的。 *可以使用cerateSQLQuery(String Sql)的方法来创建一个原始的sql查询。","categories":[],"tags":[{"name":"-java -hibernate","slug":"java-hibernate","permalink":"http://yoursite.com/tags/java-hibernate/"}]},{"title":"hello hexo!","slug":"hello-world","date":"2018-05-09T09:38:40.000Z","updated":"2018-05-21T09:58:53.038Z","comments":true,"path":"2018/05/09/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/09/hello-world/","excerpt":"","text":"你好 hexo！","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]